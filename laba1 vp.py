import numpy as np
import random

a, n0, n = 5, 2, 50
# стохастическая матрица случайного процесса
pb = np.array([[0.1, 0.2, 0.2, 0.1, 0.4],
               [0.3, 0, 0.6, 0, 0.1],
               [0.1, 0.3, 0.3, 0, 0.3],
               [0.2, 0, 0.4, 0.3, 0.1],
               [0.3, 0.2, 0, 0.4, 0.1]])

# начальное распределение вероятностей
p0 = np.array([0.1, 0.2, 0, 0.5, 0.2])

# левая часть системы уравнений
M1 = np.array([[-0.9, 0.3, 0.1, 0.2, 0.3],
               [0.2, -1, 0.3, 0, 0.2],
               [0.2, 0.6, -0.7, 0.4, 0],
               [0.1, 0, 0, -0.7, 0.4],
               [1, 1, 1, 1, 1]])

# правая часть системы уравнений
v1 = np.array([0, 0, 0, 0, 1])

# находим стационарное распределение
v = np.linalg.solve(M1, v1)

# найдем n-ю степень матрицы P
pb50 = np.linalg.matrix_power(pb, n)

# знайдемо стаціонарний розподіл імовірностей, застосовуючи формулу
p01 = np.dot(p0, pb)
p02 = np.dot(p01, pb)
step = 2
while max(abs(p01 - p02)) >= 10 ** -6:
    print(f'Шаг {step}: p = {p02}')
    p01, p02, step = p02, np.dot(p02, pb), step + 1

# расчеты стационарного распределения для других вариантов
# 10
pb = np.array([[0.1, 0.2, 0.2, 0.1, 0.4],
               [0.3, 0, 0.6, 0, 0.1],
               [0.1, 0.3, 0.3, 0, 0.3],
               [0.2, 0, 0.4, 0.3, 0.1],
               [0.3, 0.2, 0, 0.4, 0.1]])
p0 = np.array([0.3, 0.2, 0.2, 0.2, 0.1])
p01 = np.dot(p0, pb)
p02 = np.dot(p01, pb)
step1 = 2
while max(abs(p01 - p02)) >= 10 ** -6:
    print(f'Шаг {step1}: p = {p02}')
    p01, p02, step1 = p02, np.dot(p02, pb), step1 + 1

# 15
pb = np.array([[0.1, 0.2, 0.2, 0.1, 0.4],
               [0.3, 0, 0.6, 0, 0.1],
               [0.1, 0.3, 0.3, 0, 0.3],
               [0.2, 0, 0.4, 0.3, 0.1],
               [0.3, 0.2, 0, 0.4, 0.1]])
p0 = np.array([0.1, 0.3, 0.4, 0, 0.2])
p01 = np.dot(p0, pb)
p02 = np.dot(p01, pb)
step2 = 2
while max(abs(p01 - p02)) >= 10 ** -6:
    print(f'Шаг {step2}: p = {p02}')
    p01, p02, step2 = p02, np.dot(p02, pb), step2 + 1

# построим стохастические матрицы axa с поглощением
sm = np.zeros((a, a), dtype=np.float32)
for i in range(1, a - 1):
    for j in range(1, a - 1):
        if i == j:
            sm[i][j - 1] = sm[i][j + 1] = 1 / 2
sm[0][0] = sm[a - 1][a - 1] = 1

# c отображением
sm1 = np.zeros((a, a), dtype=np.float32)
for i in range(1, a - 1):
    for j in range(1, a - 1):
        if i == j:
            sm1[i][j - 1] = sm1[i][j + 1] = 1 / 2
sm1[0][1] = sm1[a - 1][a - 2] = 1

# найдем распределение вероятностей для этих процессов
# с поглощением
p6_abs = np.linalg.matrix_power(sm, 50)

# с поглощением
p6_dis = np.linalg.matrix_power(sm1, 50)

# Моделируем блуждение частицы с поглощением
k = n0
print('Модель блукання частки з поглинанням:', k, sep='\n', end=' ')
for i in range(n):
    if k in (1, a):
        k += 0
    else:
        k += random.choice((-1, 1))
    print(k, end=' ')

# с отображением
n0 = 2
k = n0
print('Модель блукання частки з відображенням:', k, sep='\n', end=' ')
for i in range(n):
    if k in (1, a):
        k += (-1 if k == a else 1)
    else:
        k += random.choice((-1, 1))
    print(k, end=' ')


